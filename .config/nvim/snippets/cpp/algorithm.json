{
  "linked-adjacency-list": {
    "prefix": "add",
    "body": [
      "const int N = $1",
      "int h[N], e[N], nxt[N], idx",
      "",
      "void add(int a, int b) {",
      "\te[idx] = b, nxt[idx] = h[a], h[a] = idx++;",
      "}",
      "$0"
    ],
    "description": "linked-adjacency-list define and add node function"
  },
  "linked-adjacency-list-with-weight": {
    "prefix": "addw",
    "body": [
      "const int N = $1, M = $2",
      "int h[N], e[M], w[M], nxt[M], idx",
      "",
      "void add(int a, int b, int c) {",
      "\te[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++;",
      "}",
      "$0"
    ],
    "description": "linked-adjacency-list define and add node function with weight"
  },
  "dijkstra": {
    "prefix": "dijk",
    "body": [
      "const int N = $1",
      "int g[N][N]",
      "int dist[N]",
      "bool st[N]",
      "",
      "int dijkstra() {",
      "\tmemset(dist, 0x3f, sizeof dist);",
      "\tdist[1] = 0",
      "",
      "\tfor (int i = 0; i < n; i++) {",
      "\t\tint t = -1;",
      "\t\tfor (int j = 1; j <= n; j++)",
      "\t\t\tif (!st[j] && (t == -1 || dist[t] > dist[j])) t = j;",
      "",
      "\t\tfor (int j = 1; j <= n; j++)",
      "\t\t\tdist[j] = min(dist[j], dist[t] + g[t][j]);",
      "\t\tst[t] = true;",
      "\t}",
      "",
      "\tif (dist[n] == 0x3f3f3f3f) return -1",
      "\treturn dist[n];",
      "}",
      "$0"
    ],
    "description": "dijkstra algorithm"
  },
  "dijkstra with heap": {
    "prefix": "Dijk",
    "body": [
      "typedef pair<int, int> PII;",
      "const int N = $1",
      "",
      "int n, m",
      "int h[N], e[N], w[N], nxt[N], idx",
      "int dist[N]",
      "bool st[N]",
      "",
      "void add(int a, int b, int c) {",
      "\te[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++;",
      "}",
      "",
      "int dijkstra() {",
      "\tmemset(dist, 0x3f, sizeof dist);",
      "\tdist[1] = 0;",
      "\tpriority_queue<PII, vector<PII>, greater<PII>> heap;",
      "\theap.push({0, 1});",
      "",
      "\twhile (heap.size()) {",
      "\t\tauto t = heap.top();",
      "\t\theap.pop();",
      "",
      "\t\tint ver = t.second, distance = t.first;",
      "",
      "\t\tif (st[ver]) continue;",
      "\t\tst[ver] = true;",
      "",
      "\t\tfor (int i = h[ver]; i != -1; i = nxt[i]) {",
      "\t\t\tint j = e[i];",
      "\t\t\tif (dist[j] > dist[ver] + w[i]) {",
      "\t\t\t\tdist[j] = dist[ver] + w[i];",
      "\t\t\t\theap.push({dist[j], j});",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\tif (dist[n] == 0x3f3f3f3f) return -1;",
      "\treturn dist[n];",
      "}",
      "$0"
    ],
    "description": "dijkstra algorithm with heap"
  },
  "spfa": {
    "prefix": "spfa",
    "body": [
      "const int N = $1",
      "",
      "int n, m;",
      "int h[N], e[N], w[N], nxt[N], idx;",
      "int dist[N];",
      "bool st[N];",
      "",
      "void add(int a, int b, int c) {",
      "\te[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++;",
      "}",
      "",
      "int spfa() {",
      "\tmemset(dist, 0x3f, sizeof dist);",
      "\tdist[1] = 0;",
      "\tqueue<int> q;",
      "\tq.push(1);",
      "\tst[1] = true;",
      "",
      "\twhile (q.size()) {",
      "\t\tint t = q.front();",
      "\t\tq.pop();",
      "\t\tst[t] = false;",
      "",
      "\t\tfor (int i = h[t]; i != -1; i = nxt[i]) {",
      "\t\t\tint j = e[i];",
      "\t\t\tif (dist[j] > dist[t] + w[i]) {",
      "\t\t\t\tdist[j] = dist[t] + w[i];",
      "\t\t\t\tif (!st[j]) {",
      "\t\t\t\t\tq.push(j);",
      "\t\t\t\t\tst[j] = true;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\tif (dist[n] == 0x3f3f3f3f) return -1;",
      "\treturn dist[n];",
      "}",
      "$0"
    ],
    "description": "spfa algorithm"
  }
}
